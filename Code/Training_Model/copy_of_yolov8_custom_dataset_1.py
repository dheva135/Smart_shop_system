# -*- coding: utf-8 -*-
"""Copy of YOLOv8_Custom_Dataset-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TAL1bUi-xtT099cHGcKfjpnFGIwlTqlc

CUSTOM DATASET TRAINING PRO-1 https://www.youtube.com/watch?v=WgPbbWmnXJ8
"""

!nvidia-smi

!pip install ultralytics

!pip install clearml

from ultralytics import YOLO

"""Custom data training

we have downloaded the zip file from roboflow if zip not needed then use API
"""

# !pip install roboflow

# from roboflow import Roboflow
# rf = Roboflow(api_key="b1kGbSViAOhiyQlkusWv")
# project = rf.workspace("ws1-xmudm").project("seg_all")
# version = project.version(4)
# dataset = version.download("yolov8")

#for segmentation
!yolo task=segment mode=train model=yolov8n-seg.pt data=/content/drive/MyDrive/dataset/seg_all3/data.yaml epochs=25 imgsz=640

#for detection
#!yolo task=detect mode=train model=yolov8m.pt data=../content/drive/MyDrive/dataset/dataset-all-1/data.yaml epochs=50 imgsz=640

# Commented out IPython magic to ensure Python compatibility.
# Look at training curves in tensorboard:
# %load_ext tensorboard
# %tensorboard --logdir runs/segment/train
# %tensorboard --logdir $OUTPUT_DIR_PATH #'/content/training/train'

from IPython.display import Image

Image("/content/runs/segment/train/results.png")

Image(filename='/content/runs/segment/train/train_batch3585.jpg', width=900)

"""Run inference

Now that our model is trained, we can use it for inference.
"""

my_new_model = YOLO('/content/runs/segment/train/weights/best.pt')

"""Load an image and perform inference (segmentation)."""

new_image = '/content/runs/segment/train/train_batch3587.jpg'
new_results = my_new_model.predict(new_image, conf=0.2)  #Adjust conf threshold

import matplotlib.pyplot as plt
new_result_array = new_results[0].plot()
plt.figure(figsize=(12, 12))
plt.imshow(new_result_array)

"""Extracting bounding boxes and segmented masks from the result"""

new_result = new_results[0]

"""Extracting segmented masks"""

extracted_masks = new_result.masks.data
extracted_masks.shape
masks_array = extracted_masks.cpu().numpy()
plt.imshow(masks_array[0]) #mysore

"""Extracting labels for each class"""

plt.imshow(masks_array[1]) #Tide bar

class_names = new_result.names.values()
class_names

# Extract the boxes, which likely contain class IDs
detected_boxes = new_result.boxes.data
# Extract class IDs from the detected boxes
class_labels = detected_boxes[:, -1].int().tolist()
# Initialize a dictionary to hold masks by class
masks_by_class = {name: [] for name in new_result.names.values()}

# Iterate through the masks and class labels
for mask, class_id in zip(extracted_masks, class_labels):
    class_name = new_result.names[class_id]  # Map class ID to class name
    masks_by_class[class_name].append(mask.cpu().numpy())


for class_name, masks in masks_by_class.items():
    print(f"Class Name: {class_name}, Number of Masks: {len(masks)}")

"""Extracting masks for a specific class


"""

alpha_granule_masks = masks_by_class['Patanjali_Dant_Kanti']
cell_masks = masks_by_class['Hamam_Soap']

# Extract the original image
orig_img = new_result.orig_img

orig_img.shape

# Display the original image
plt.imshow(orig_img, cmap='gray')

# Overlay the mask with some transparency
#plt.imshow(alpha_granule_masks[0], cmap='jet', alpha=0.3)
plt.imshow(cell_masks[0], cmap='jet', alpha=0.5)
plt.axis('off') # Turn off axis labels
plt.show()

"""Calculating region properties for all objects and saving to a csv file."""

# Display the original image
plt.imshow(orig_img, cmap='gray')

# Overlay the mask with some transparency
plt.imshow(alpha_granule_masks[0], cmap='jet', alpha=0.5)
#plt.imshow(cell_masks[0], cmap='jet', alpha=0.5)
plt.axis('off') # Turn off axis labels
plt.show()

import pandas as pd
from skimage.measure import regionprops

# Initialize a list to store the properties
props_list = []

# Iterate through all classes
for class_name, masks in masks_by_class.items():
    # Iterate through the masks for this class
    for mask in masks:
        # Convert the mask to an integer type if it's not already
        mask = mask.astype(int)

        # Apply regionprops to the mask
        props = regionprops(mask)

        # Extract the properties you want (e.g., area, perimeter) and add them to the list
        for prop in props:
            area = prop.area
            perimeter = prop.perimeter
            # Add other properties as needed

            # Append the properties and class name to the list
            props_list.append({'Class Name': class_name, 'Area': area, 'Perimeter': perimeter})

# Convert the list of dictionaries to a DataFrame
props_df = pd.DataFrame(props_list)

# Now props_df contains the properties and class names for all regions

# Save the DataFrame to a CSV file
props_df.to_csv('/content/drive/MyDrive/dataset/seg_all3/YOLOv8_object_properties.csv', index=False)

props_df

"""Plotting results"""

import seaborn as sns
# Create the swarm plot with Seaborn
sns.swarmplot(x='Class Name', y='Area', data=props_df)

# Add labels and a title
plt.xlabel('Class Name')
plt.ylabel('Area')
plt.title('Area of Objects for Each Class')

# Rotate the x-axis labels for better visibility if needed
plt.xticks(rotation=45)

# Show the plot
plt.show()

"""BOX-PLOT"""

sns.boxplot(x='Class Name', y='Area', data=props_df)
# Add labels and a title
plt.xlabel('Class Name')
plt.ylabel('Area')
plt.title('Area of Objects for Each Class')

# Rotate the x-axis labels for better visibility if needed
plt.xticks(rotation=45)

# Show the plot
plt.show()

from google.colab import drive
drive.mount('/content/drive')

!yolo val model=/content/runs/detect/train/weights/best.pt data=/content/drive/MyDrive/YOLOv8_Custom_dataset-1/data.yaml

"""Comparison graph"""

import matplotlib.pyplot as plt
import pandas as pd

# Assuming you have extracted predictions from both models into dataframes
yolov5_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov5/yolov5_results.csv")
yolov8_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8n.csv")
yolov7_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov7/yolov7_results.csv")

# Example: Plotting comparison of confidence scores for a specific class
# class_to_compare = "car"
# yolov5_class_scores = yolov5_predictions[yolo_predictions['class'] == class_to_compare]['confidence']
# yolov8_class_scores = yolov8_predictions[detectron_predictions['class'] == class_to_compare]['confidence']

column_names = yolov7_predictions.columns.tolist()
column_names = [col.strip() for col in yolov7_predictions.columns.tolist()]
#print("Column Names:", column_names)

yolov5_class_scores = yolov5_predictions['metrics/mAP_0.5:0.95']
yolov8_class_scores = yolov8_predictions['    metrics/mAP50-95(B)']
yolov7_class_scores = yolov7_predictions['metrics/mAP_0.5:0.95']

epochs = range(0, 25)

# Create x-axis for each instance
# x_yolo = range(1, len(yolo_class_scores) + 1)
# x_detectron = range(1, len(detectron_class_scores) + 1)

# Plotting line graph
# plt.plot(x_yolo, yolo_class_scores, label='YOLO')
# plt.plot(x_detectron, detectron_class_scores, label='Detectron2')

plt.plot(epochs,yolov5_class_scores[:len(epochs)],label='YOLOv5')
plt.plot(epochs,yolov8_class_scores[:len(epochs)],label='YOLOv8')
plt.plot(epochs,yolov7_class_scores[:len(epochs)],label='YOLOv7')


plt.legend(loc='upper right')
plt.xlabel('Number of epochs')
plt.ylabel('metrics/mAP50-95(B)')
plt.title(f'Comparison of metrics/mAP50-95(B) vs epochs')
plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Load predictions from CSV files
yolov8n_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8n.csv")
yolov8s_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8s.csv")
yolov8m_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8m.csv")
yolov8l_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8l.csv")
yolov8x_predictions = pd.read_csv("/content/drive/MyDrive/Segment/results/yolov8/yolov8x.csv")

# Print column names for verification
# print("Column Names:", yolov8n_predictions.columns.tolist())
# print("Column Names:", yolov8s_predictions.columns.tolist())
# print("Column Names:", yolov8m_predictions.columns.tolist())
# print("Column Names:", yolov8l_predictions.columns.tolist())
# print("Column Names:", yolov8x_predictions.columns.tolist())

# Extract mAP50-95(B) scores
yolov8n_class_scores = yolov8n_predictions['    metrics/mAP50-95(B)']
yolov8s_class_scores = yolov8s_predictions['    metrics/mAP50-95(B)']
yolov8m_class_scores = yolov8m_predictions['    metrics/mAP50-95(B)']
yolov8l_class_scores = yolov8l_predictions['    metrics/mAP50-95(B)']
yolov8x_class_scores = yolov8x_predictions['    metrics/mAP50-95(B)']

# Define the number of epochs
epochs = range(0, 25)

# Plotting line graph
plt.plot(epochs, yolov8n_class_scores[:len(epochs)], label='YOLOv8n', color='r')
plt.plot(epochs, yolov8s_class_scores[:len(epochs)], label='YOLOv8s', color='g')
plt.plot(epochs, yolov8m_class_scores[:len(epochs)], label='YOLOv8m', color='c')
plt.plot(epochs, yolov8l_class_scores[:len(epochs)], label='YOLOv8l', color='orange')
plt.plot(epochs, yolov8x_class_scores[:len(epochs)], label='YOLOv8x', color='m')

# Add legend, labels, and title
plt.legend(loc='lower right')
plt.xlabel('Number of epochs')
plt.ylabel('metrics/mAP50-95(B)')
plt.title('Comparison of metrics/mAP50-95(B) vs epochs')

# Show the plot
plt.show()